/**
 * @file unique_id_assignmentCode.cpp
 * Generated by VisibleSim BlockCode Generator
 * https://services-stgi.pu-pm.univ-fcomte.fr/visiblesim/generator.php#
 * @author Hovhannes STEPANYAN
 * @date 17-11-2022
 **/
#include "unique_id_assignmentCode.hpp"

Unique_ID_AssignmentCode::Unique_ID_AssignmentCode(BlinkyBlocksBlock *host) : BlinkyBlocksBlockCode(host), module(host) {
    // @warning Do not remove block below, as a blockcode with a NULL host might be created
    //  for command line parsing
    if (not host) return;

    // Registers a callback (myBroadcastFunc) to the message of type R
    addMessageEventFunc2(GO_MSG_ID,
                         std::bind(&Unique_ID_AssignmentCode::myGoFunc, this,
                                   std::placeholders::_1, std::placeholders::_2));

    addMessageEventFunc2(BACK_MSG_ID, std::bind(&Unique_ID_AssignmentCode::myBackFunc, this,
                                                std::placeholders::_1, std::placeholders::_2));

    addMessageEventFunc2(PASS_MSG_ID, std::bind(&Unique_ID_AssignmentCode::messagePassingFunction, this,
                                                std::placeholders::_1, std::placeholders::_2));
}

void Unique_ID_AssignmentCode::startup() {
    // console << "start " << getId() << "\n";

    if (isLeader) {
        // set is discovered
        isDiscovered = true;

        // myDistance = 0;
        setColor(RED);
        numberOfAwaitingReplies = sendMessageToAllNeighbors("GO", new MessageOf<int>(GO_MSG_ID, myUniqueID), 100, 1000, 0);
    }
}

void Unique_ID_AssignmentCode::myGoFunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender) {
    MessageOf<int> *msg = static_cast<MessageOf<int> *>(_msg.get());
    int msgData = *msg->getData();

    if (isDiscovered) {
        setColor(GREEN);
        // send message to sender
        sendMessage("BACK", new MessageOf<int>(BACK_MSG_ID, numberOfNodesAfterMe), sender, 1000, 0);
    } else {
        // set is discovered and save the parent
        parent = sender;
        isDiscovered = true;

        // send type GO message all neighbors except the parent
        numberOfAwaitingReplies = sendMessageToAllNeighbors("GO", new MessageOf<int>(GO_MSG_ID, msgData), 100, 1000, 1, parent);

        // if numberOfAwaitingReplies is 0 it means we reached the end of the tree and we can send the message to the parent
        if (numberOfAwaitingReplies == 0) {
            setColor(GREEN);
            numberOfNodesAfterMe++;
            // send type BACK message to parent
            sendMessage("BACK", new MessageOf<int>(BACK_MSG_ID, numberOfNodesAfterMe), parent, 1000, 0);
        }
    }
}

void Unique_ID_AssignmentCode::myBackFunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender) {
    MessageOf<int> *msg = static_cast<MessageOf<int> *>(_msg.get());
    int numberOfNodes = *msg->getData();

    // decrease by one number of awaiting replies
    numberOfAwaitingReplies--;
    // add to the total of numberOfNodesAfterMe
    numberOfNodesAfterMe += numberOfNodes;

    // append the sender and numberOfNodes of that child to the children vector if numberOfNodes is not 0
    if (numberOfNodes != 0) {
        children.push_back(std::make_pair(sender, numberOfNodes));
    }

    if (numberOfAwaitingReplies == 0) {
        // if the leader it means we calculated all numbers now start asigning the unique ids
        if (isLeader) {
            // console << "Number of nodes: " << numberOfNodesAfterMe << "\n";

            int initialUniqueID = myUniqueID + 1;

            // loop over the children and send the message
            for (auto &block : children) {
                // cout << "Number of nodes after me: " << block.second << "\n";
                // create an array of integers starting from initialUniqueID and with length of child numberOfNodesAfterMe (block.second)
                vector<int> arrayOfUniqueIDs;
                // cout << "In loop initialUniqueID: " << initialUniqueID << "\n";
                // cout << "In loop sum: " << initialUniqueID + block.second << "\n";
                for (int i = initialUniqueID; i < initialUniqueID + block.second; i++) {
                    arrayOfUniqueIDs.push_back(i);
                }
                // loop and cout arrayOfUniqueIDs
                // for (int i = 0; i < block.second; i++) {
                //     cout << "arrayOfUniqueIDs[" << i << "]: " << arrayOfUniqueIDs[i] << "\n";
                // }

                initialUniqueID = initialUniqueID + block.second;
                sendMessage("PASS", new MessageOf<vector<int> >(PASS_MSG_ID, arrayOfUniqueIDs), block.first, 1000, 0);
            }
        } else {
            setColor(ORANGE);
            numberOfNodesAfterMe++;
            // send type BACK message to parent
            sendMessage("BACK", new MessageOf<int>(BACK_MSG_ID, numberOfNodesAfterMe), parent, 1000, 0);
        }
    }
}

void Unique_ID_AssignmentCode::messagePassingFunction(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender) {
    MessageOf<vector<int> > *msg = static_cast<MessageOf<vector<int> > *>(_msg.get());
    vector<int> arrayOfUniqueIDs = *msg->getData();

    // take the first id from the arrayOfUniqueIDs and send the other ids to the children
    myUniqueID = arrayOfUniqueIDs[0];
    arrayOfUniqueIDs.erase(arrayOfUniqueIDs.begin());

    setColor(myUniqueID);
    // cout << "------- "
    //      << "\n";
    // cout << "My unique id is: " << myUniqueID << "\n";
    // cout << "Number of my children: " << children.size() << "\n";
    // console << "My unique id is: " << myUniqueID << "\n";

    // check if has children
    if (children.size() > 0) {
        // int initialUniqueID = myUniqueID + 1;

        // loop over the children and send the message
        for (auto &block : children) {
            // create an vector of integers and fill it with the ids from arrayOfUniqueIDs bases on the number of nodes after that child
            vector<int> arrayOfUniqueIDsForChild;
            // check if the child has nodes after him
            if (block.second > 0) {
                // cout << "In loop number of nodes after child: " << block.second << "\n";
                // loop over the number of nodes after that child and add the ids to the arrayOfUniqueIDsForChild
                // and remove used ones from the arrayOfUniqueIDs
                for (int i = 0; i < block.second; i++) {
                    arrayOfUniqueIDsForChild.push_back(arrayOfUniqueIDs[0]);
                    arrayOfUniqueIDs.erase(arrayOfUniqueIDs.begin());
                }
                // loop and cout arrayOfUniqueIDs
                // for (int i = 0; i < block.second; i++) {
                //     cout << "arrayOfUniqueIDsForChild[" << i << "]: " << arrayOfUniqueIDsForChild[i] << "\n";
                // }

                sendMessage("PASS", new MessageOf<vector<int> >(PASS_MSG_ID, arrayOfUniqueIDsForChild), block.first, 1000, 0);
            }
        }
    } else {
        // cout << "I am a leaf node\n";
        // console << "I am a leaf node\n";
    }
}

void Unique_ID_AssignmentCode::parseUserBlockElements(TiXmlElement *config) {
    const char *attr = config->Attribute("leader");
    if (attr != nullptr) {
        std::cout << getId() << " is leader!" << std::endl;  // complete with your code
        isLeader = true;
        // set my unique ID
        myUniqueID = 0;
    }
}
